// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";

contract Ownable {
  //using SafeMath for uint256;

  address private owner;
  address private nextOwner;
  uint public hidden_number1;
  uint public hidden_number2;
  uint private owner_count=0;
  uint private request_key;
  bool private request=false;
  bool private open_request=false;
  address public requested_owner;
  uint private message;

  constructor() {
    owner = msg.sender;
  }

  mapping(address => uint) private owner_list;

  modifier onlyOwner() {
    require(msg.sender == owner, "Only the owner can perform this action");
    _;
  }

  modifier requestOkay() {
      require(request==true,"No request for initialization");
      _;
  }

  function openRequestAccess(address _requested_owner, uint _request_key) public onlyOwner {
      require(open_request==false);
      require(request==false);
      require(_requested_owner!=owner);
      requested_owner=_requested_owner;
      request_key=_request_key;
      open_request=true;

  }

  function requestAccess(uint _key) public {
      require(request==false);
      require(open_request==true);
      require(requested_owner==msg.sender);
      require(request_key==_key);
      request=true;
      open_request=false;


  }

  function transferOwnership(address _newOwner, uint _h1, uint _h2, uint _message) public onlyOwner requestOkay {
    require(_newOwner != address(0), "The new owner cannot be the null address");
    require(_newOwner != owner, "The new owner must be different from the current owner");
    //require(_encryptedKey > 0, "The encrypted key must be a non-empty string");
    require(owner_list[owner]==0);

    nextOwner = _newOwner;
    hidden_number1 = _h1;
    hidden_number2 = _h2;
    message=_message;
    owner_list[owner]++;
    owner_count++;
  }

  function acceptOwnership(uint _checkMessage,uint _owner_count) public {
    require(msg.sender == nextOwner, "Only the next owner can accept ownership");
    require(_owner_count==owner_count);
    require(message==_checkMessage);
    require(owner_list[msg.sender]==0);

    owner = nextOwner;
    owner_list[msg.sender]++;
    
    nextOwner = address(0);
    hidden_number1 = 0;
    hidden_number2 = 0;
  }

  function transferOwnershipToAnotherParty(address _anotherParty, uint _h1,uint _h2, uint _message) public onlyOwner {
    require(_anotherParty != address(0), "The another party cannot be the null address");
    require(_anotherParty != owner, "The another party must be different from the current owner");
    //require(_encryptedKey > 0, "The encrypted key must be a non-empty string");
    require(owner_list[owner]==1);

    owner_list[owner]++;
    nextOwner = _anotherParty;
    hidden_number1 = _h1;
    hidden_number2 = _h2;
    message=_message;
    owner_count++;
  }




  //Election Process
  struct Candidate {
        string name;
        uint256 voteCount;
        uint256 id;
    }

    struct Voter {
        //address voterr;
        //uint weight;
        bool votedd;
        bool authorizedd;
        //string votername;

        //uint256 vote;
    }

    uint public expiration;
    uint256 public winningVote = 0;
    string public winnerName;
    string public electionName;
    string public names;
   

    //mapping(address => Voter) public voterss;
    mapping(address => Voter) public voted;

    Candidate[5] public candidates;
    Voter[] public voters;

    uint256 public totalVotes;

    uint256 public next_candidate = 0;

    enum State {
        Pre_election,
        Created,
        Voting,
        Ended
    }
    State public state=State.Pre_election;

    modifier inState(State _state) {
        require(state == _state);
        _;
    }


     function startElection(uint256 checkX) public onlyOwner inState(State.Pre_election) {
      require(owner_count>0);
      require(checkX==owner_count);
      require(owner_list[owner]==1);
      owner_list[owner]++;
        //electionName = _name;
      state = State.Created;
    }

    function addCandidate(string memory _name, uint256 _id)
        public
        inState(State.Created)
        onlyOwner
    {
        console.log("log 1");
        
        console.log("log else");
        if (next_candidate >= candidates.length) {
            console.log("No spots left");
            return;
        }
        for (uint256 i = 0; i < next_candidate; i++) {
            console.log("log 2");
            if (candidates[i].id == _id) {
                console.log("Same id");
                return;
            }
        }

        candidates[next_candidate].name = _name;
        candidates[next_candidate].voteCount = 0;
        candidates[next_candidate].id = _id;
        //next_candidate++;
        if (next_candidate + 1 < candidates.length) {
            next_candidate++;
        }
        console.log("XX");
    }


    function authorize(address person) public inState(State.Created) onlyOwner {
        //voted[person].weight = 1;
        //voters.push(Voter(_person, true,false));
        // users[userCounter] = _address;
        //isRegistered[person] = true;
        //authorizedAddresses[_address] = true;
        //voted[person].authorizedd = true;
        voted[person].authorizedd = true;
    }

    function startVote() public inState(State.Created) onlyOwner {
        expiration = block.timestamp + 30 seconds;
        state = State.Voting;
        
    }

    function checkExpiration() public inState(State.Voting) view returns (bool) {
        return block.timestamp >= expiration;
    }

    function vote(uint256 _voteIndex) public inState(State.Voting) {
        // Check if the time limit for voting has been reached
        if (checkExpiration()) {
            // Time limit has been reached, do not allow the vote to be cast
            console.log("Time is over");
            for(uint i=0;i<candidates.length;i++)
            {
                if(candidates[i].voteCount>winningVote)
                {
                    winningVote=candidates[i].voteCount;
                    winnerName=candidates[i].name;
                }
            }
            state = State.Ended;
            showResult();
            return;
        }
        else
        {
            //console.log("Time ase mama");
            require(voted[msg.sender].votedd == false, "user already voted");
            require(voted[msg.sender].authorizedd == true, "problem occuring here");
            candidates[_voteIndex].voteCount += 1;
            totalVotes += 1;
            voted[msg.sender].votedd = true;
            
        }
        
    }

    function terminate() public inState(State.Voting) onlyOwner {
        for(uint i=0;i<candidates.length;i++)
        {
            if(candidates[i].voteCount>winningVote)
            {
                winningVote=candidates[i].voteCount;
                winnerName=candidates[i].name;
            }
        }
        state = State.Ended;
    }


    function showResult() public inState(State.Ended) view returns (string memory) {
        return winnerName;
    }






}



